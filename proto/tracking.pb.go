// Code generated by protoc-gen-go.
// source: tracking.proto
// DO NOT EDIT!

/*
Package proto is a generated protocol buffer package.

It is generated from these files:
	tracking.proto

It has these top-level messages:
	SysMigrationsStatus
	SysTrackingStatus
	TrackingTimesheet
	TrackingEntry
	TrackingEntryRef
*/
package proto

import proto1 "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto1.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto1.ProtoPackageIsVersion2 // please upgrade the proto package

// SysMigrationsStatus represents the current state of backend migrations.
type SysMigrationsStatus struct {
	// The versions that have been applied.
	Versions []uint64 `protobuf:"varint,1,rep,packed,name=versions" json:"versions,omitempty"`
}

func (m *SysMigrationsStatus) Reset()                    { *m = SysMigrationsStatus{} }
func (m *SysMigrationsStatus) String() string            { return proto1.CompactTextString(m) }
func (*SysMigrationsStatus) ProtoMessage()               {}
func (*SysMigrationsStatus) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *SysMigrationsStatus) GetVersions() []uint64 {
	if m != nil {
		return m.Versions
	}
	return nil
}

// SysTrackingStatus represents the current state of tracking, i.e. whether or not a timer is
// running, or which timer we last modified.
type SysTrackingStatus struct {
	// Whether or not a (any) timer is running.
	IsRunning bool `protobuf:"varint,1,opt,name=is_running,json=isRunning" json:"is_running,omitempty"`
	// The date of the timesheet currently being tracked.
	Timesheet string `protobuf:"bytes,2,opt,name=timesheet" json:"timesheet,omitempty"`
	// The hash of the entry currently being tracked.
	Entry string `protobuf:"bytes,3,opt,name=entry" json:"entry,omitempty"`
	// The name of the workspace currently being tracked.
	Workspace string `protobuf:"bytes,4,opt,name=workspace" json:"workspace,omitempty"`
}

func (m *SysTrackingStatus) Reset()                    { *m = SysTrackingStatus{} }
func (m *SysTrackingStatus) String() string            { return proto1.CompactTextString(m) }
func (*SysTrackingStatus) ProtoMessage()               {}
func (*SysTrackingStatus) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *SysTrackingStatus) GetIsRunning() bool {
	if m != nil {
		return m.IsRunning
	}
	return false
}

func (m *SysTrackingStatus) GetTimesheet() string {
	if m != nil {
		return m.Timesheet
	}
	return ""
}

func (m *SysTrackingStatus) GetEntry() string {
	if m != nil {
		return m.Entry
	}
	return ""
}

func (m *SysTrackingStatus) GetWorkspace() string {
	if m != nil {
		return m.Workspace
	}
	return ""
}

// TrackingTimesheet represents a timesheet. It contains all of the entries for a time period.
type TrackingTimesheet struct {
	// The key of this timesheet.
	Key string `protobuf:"bytes,1,opt,name=key" json:"key,omitempty"`
	// A timesheet consists of many entries. A timesheet can be totally empty, it's just there to
	// hold the reference to a bunch of entries under a date, i.e. for easy access.
	Entries []string `protobuf:"bytes,2,rep,name=entries" json:"entries,omitempty"`
}

func (m *TrackingTimesheet) Reset()                    { *m = TrackingTimesheet{} }
func (m *TrackingTimesheet) String() string            { return proto1.CompactTextString(m) }
func (*TrackingTimesheet) ProtoMessage()               {}
func (*TrackingTimesheet) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *TrackingTimesheet) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *TrackingTimesheet) GetEntries() []string {
	if m != nil {
		return m.Entries
	}
	return nil
}

// TrackingEntry represents an entry in the timesheet. This will have enough information to commit
// to the duration, and also enough information to identify the entry.
type TrackingEntry struct {
	// The key of this entry.
	Key string `protobuf:"bytes,1,opt,name=key" json:"key,omitempty"`
	// The key of the timesheet this entry belongs to.
	Timesheet string `protobuf:"bytes,2,opt,name=timesheet" json:"timesheet,omitempty"`
	// The note associated with this entry.
	Note string `protobuf:"bytes,3,opt,name=note" json:"note,omitempty"`
	// The unix timestamp of when this entry was created.
	Created uint64 `protobuf:"varint,4,opt,name=created" json:"created,omitempty"`
	// The unix timestamp of when this entry was last updated.
	Updated uint64 `protobuf:"varint,5,opt,name=updated" json:"updated,omitempty"`
	// The number of seconds this has been tracked for (once committed).
	Duration uint64 `protobuf:"varint,6,opt,name=duration" json:"duration,omitempty"`
}

func (m *TrackingEntry) Reset()                    { *m = TrackingEntry{} }
func (m *TrackingEntry) String() string            { return proto1.CompactTextString(m) }
func (*TrackingEntry) ProtoMessage()               {}
func (*TrackingEntry) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *TrackingEntry) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *TrackingEntry) GetTimesheet() string {
	if m != nil {
		return m.Timesheet
	}
	return ""
}

func (m *TrackingEntry) GetNote() string {
	if m != nil {
		return m.Note
	}
	return ""
}

func (m *TrackingEntry) GetCreated() uint64 {
	if m != nil {
		return m.Created
	}
	return 0
}

func (m *TrackingEntry) GetUpdated() uint64 {
	if m != nil {
		return m.Updated
	}
	return 0
}

func (m *TrackingEntry) GetDuration() uint64 {
	if m != nil {
		return m.Duration
	}
	return 0
}

// TrackingEntryRef represents a reference from an entry's short key to it's full key.
type TrackingEntryRef struct {
	// The key of this entry reference.
	Key string `protobuf:"bytes,1,opt,name=key" json:"key,omitempty"`
	// The key of the entry this reference belongs to.
	Entry string `protobuf:"bytes,2,opt,name=entry" json:"entry,omitempty"`
}

func (m *TrackingEntryRef) Reset()                    { *m = TrackingEntryRef{} }
func (m *TrackingEntryRef) String() string            { return proto1.CompactTextString(m) }
func (*TrackingEntryRef) ProtoMessage()               {}
func (*TrackingEntryRef) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *TrackingEntryRef) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *TrackingEntryRef) GetEntry() string {
	if m != nil {
		return m.Entry
	}
	return ""
}

func init() {
	proto1.RegisterType((*SysMigrationsStatus)(nil), "proto.SysMigrationsStatus")
	proto1.RegisterType((*SysTrackingStatus)(nil), "proto.SysTrackingStatus")
	proto1.RegisterType((*TrackingTimesheet)(nil), "proto.TrackingTimesheet")
	proto1.RegisterType((*TrackingEntry)(nil), "proto.TrackingEntry")
	proto1.RegisterType((*TrackingEntryRef)(nil), "proto.TrackingEntryRef")
}

func init() { proto1.RegisterFile("tracking.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 288 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x7c, 0x51, 0x4f, 0x4b, 0xfd, 0x30,
	0x10, 0x24, 0xfd, 0xf3, 0x7e, 0xaf, 0x0b, 0x3f, 0x79, 0x2f, 0x7a, 0x08, 0xa2, 0x50, 0x7a, 0xea,
	0x49, 0x10, 0x6f, 0x5e, 0x3c, 0x79, 0xf4, 0x92, 0xbe, 0xbb, 0xd4, 0x76, 0xad, 0xa1, 0x98, 0x96,
	0x64, 0xab, 0xf4, 0xee, 0x37, 0xf1, 0x8b, 0x4a, 0xd2, 0x3f, 0x2a, 0x8a, 0xa7, 0x64, 0x66, 0x98,
	0xd9, 0x61, 0x17, 0x8e, 0xc8, 0x94, 0x55, 0xab, 0x74, 0x73, 0xd1, 0x9b, 0x8e, 0x3a, 0x1e, 0xfb,
	0x27, 0xbb, 0x84, 0xe3, 0x62, 0xb4, 0x77, 0xaa, 0x31, 0x25, 0xa9, 0x4e, 0xdb, 0x82, 0x4a, 0x1a,
	0x2c, 0x3f, 0x85, 0xed, 0x0b, 0x1a, 0xeb, 0x18, 0xc1, 0xd2, 0x30, 0x8f, 0xe4, 0x8a, 0xb3, 0x37,
	0x06, 0xfb, 0x62, 0xb4, 0x87, 0x39, 0x6f, 0x76, 0x9c, 0x03, 0x28, 0x7b, 0x6f, 0x06, 0xad, 0x95,
	0x6e, 0x04, 0x4b, 0x59, 0xbe, 0x95, 0x89, 0xb2, 0x72, 0x22, 0xf8, 0x19, 0x24, 0xa4, 0x9e, 0xd1,
	0x3e, 0x21, 0x92, 0x08, 0x52, 0x96, 0x27, 0xf2, 0x93, 0xe0, 0x27, 0x10, 0xa3, 0x26, 0x33, 0x8a,
	0xd0, 0x2b, 0x13, 0x70, 0x9e, 0xd7, 0xce, 0xb4, 0xb6, 0x2f, 0x2b, 0x14, 0xd1, 0xe4, 0x59, 0x89,
	0xec, 0x06, 0xf6, 0x4b, 0x85, 0xc3, 0x1a, 0xb4, 0x83, 0xb0, 0xc5, 0xd1, 0x8f, 0x4f, 0xa4, 0xfb,
	0x72, 0x01, 0xff, 0x5c, 0x9a, 0x42, 0x2b, 0x82, 0x34, 0xcc, 0x13, 0xb9, 0xc0, 0xec, 0x9d, 0xc1,
	0xff, 0x25, 0xe1, 0xd6, 0x0f, 0xfc, 0xe9, 0xfe, 0xbb, 0x36, 0x87, 0x48, 0x77, 0x84, 0x73, 0x6b,
	0xff, 0x77, 0xf3, 0x2a, 0x83, 0x25, 0x61, 0xed, 0x2b, 0x47, 0x72, 0x81, 0x4e, 0x19, 0xfa, 0xda,
	0x2b, 0xf1, 0xa4, 0xcc, 0xd0, 0x6d, 0xbb, 0x1e, 0xa6, 0x03, 0x88, 0x8d, 0x97, 0x56, 0x9c, 0x5d,
	0xc3, 0xee, 0x5b, 0x49, 0x89, 0x8f, 0xbf, 0xf4, 0x5c, 0x17, 0x18, 0x7c, 0x59, 0xe0, 0xc3, 0xc6,
	0xdf, 0xf8, 0xea, 0x23, 0x00, 0x00, 0xff, 0xff, 0x40, 0x51, 0x1e, 0xbf, 0xfc, 0x01, 0x00, 0x00,
}
